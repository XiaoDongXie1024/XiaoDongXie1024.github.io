<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.4.2">


  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=6.4.2" color="#222">



  <meta name="msapplication-config" content="/images/browserconfig.xml" />







<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="在类似直播的功能界面,二维码扫描，人脸识别或其他需求中需要从相机捕获的画面中单独截取出一部分区域.">
<meta name="keywords" content="sampleBuffer, CaptureSession, crop, iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS开发中截取相机部分画面，切割sampleBuffer（Crop sample buffer）">
<meta property="og:url" content="https://XiaoDongXie1024.github.io/2018/02/23/cropSampleBuffer/index.html">
<meta property="og:site_name" content="小东邪 Show Time">
<meta property="og:description" content="在类似直播的功能界面,二维码扫描，人脸识别或其他需求中需要从相机捕获的画面中单独截取出一部分区域.">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5086522-8dcd2cde5f0b23a3.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/5086522-5f510e448af32d4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://cl.ly/0O070Z391Y3m/Snip20170802_2.png">
<meta property="og:image" content="https://cl.ly/1B3X230y0l1m/Snip20170802_1.png">
<meta property="og:updated_time" content="2018-10-25T09:19:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS开发中截取相机部分画面，切割sampleBuffer（Crop sample buffer）">
<meta name="twitter:description" content="在类似直播的功能界面,二维码扫描，人脸识别或其他需求中需要从相机捕获的画面中单独截取出一部分区域.">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/5086522-8dcd2cde5f0b23a3.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">






  <link rel="canonical" href="https://XiaoDongXie1024.github.io/2018/02/23/cropSampleBuffer/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS开发中截取相机部分画面，切割sampleBuffer（Crop sample buffer） | 小东邪 Show Time</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小东邪 Show Time</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-桃花岛">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />桃花岛</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-时间轴">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />时间轴</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-武功秘籍">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />武功秘籍</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-江湖地位">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />江湖地位</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-江湖历程">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-futbol-o"></i> <br />江湖历程</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://XiaoDongXie1024.github.io/2018/02/23/cropSampleBuffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小东邪 - Demon">
      <meta itemprop="description" content="一生负气成今日，四海无人对夕阳.">
      <meta itemprop="image" content="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/yzeIpXHXXaOcxOnovNgST0jvIeuupEGzPfZ3DWoYrLY!/r/dFQBAAAAAAAA">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小东邪 Show Time">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS开发中截取相机部分画面，切割sampleBuffer（Crop sample buffer）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-02-23 17:48:29" itemprop="dateCreated datePublished" datetime="2018-02-23T17:48:29+08:00">2018-02-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-10-25 17:19:47" itemprop="dateModified" datetime="2018-10-25T17:19:47+08:00">2018-10-25</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/视频-Video/" itemprop="url" rel="index"><span itemprop="name">视频(Video)</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/23/cropSampleBuffer/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments: </span> <span class="post-comments-count gitment-comments-count" data-xid="/2018/02/23/cropSampleBuffer/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/02/23/cropSampleBuffer/" class="leancloud_visitors" data-flag-title="iOS开发中截取相机部分画面，切割sampleBuffer（Crop sample buffer）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Views: </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             Views:  
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          
              <div class="post-description">在类似直播的功能界面,二维码扫描，人脸识别或其他需求中需要从相机捕获的画面中单独截取出一部分区域.</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p class="description"></p>

<a id="more"></a>
<h2 id="iOS开发中截取相机部分画面，切割sampleBuffer（Crop-sample-buffer）"><a href="#iOS开发中截取相机部分画面，切割sampleBuffer（Crop-sample-buffer）" class="headerlink" title="iOS开发中截取相机部分画面，切割sampleBuffer（Crop sample buffer）"></a>iOS开发中截取相机部分画面，切割sampleBuffer（Crop sample buffer）</h2><h3 id="本例需求：在类似直播的功能界面-二维码扫描，人脸识别或其他需求中的功能界面或其他需求中需要从相机捕获的画面中单独截取出一部分区域。"><a href="#本例需求：在类似直播的功能界面-二维码扫描，人脸识别或其他需求中的功能界面或其他需求中需要从相机捕获的画面中单独截取出一部分区域。" class="headerlink" title="本例需求：在类似直播的功能界面,二维码扫描，人脸识别或其他需求中的功能界面或其他需求中需要从相机捕获的画面中单独截取出一部分区域。"></a>本例需求：在类似直播的功能界面,二维码扫描，人脸识别或其他需求中的功能界面或其他需求中需要从相机捕获的画面中单独截取出一部分区域。</h3><h3 id="原理：由于需要截取相机捕获整个画面其中一部分，所以也就必须拿到那一部分画面的数据，又因为相机AVCaptureVideoDataOutputSampleBufferDelegate中的sampleBuffer为系统私有的数据结构不可直接操作，所以需要将其转换成可以切割的数据结构再进行切割，网上有种思路说将sampleBuffer间接转换为UIImage再对图片切割，这种思路繁琐且性能低，本例将sampleBuffer转换为CoreImage中的CIImage-性能相对较高且降低代码繁琐度。"><a href="#原理：由于需要截取相机捕获整个画面其中一部分，所以也就必须拿到那一部分画面的数据，又因为相机AVCaptureVideoDataOutputSampleBufferDelegate中的sampleBuffer为系统私有的数据结构不可直接操作，所以需要将其转换成可以切割的数据结构再进行切割，网上有种思路说将sampleBuffer间接转换为UIImage再对图片切割，这种思路繁琐且性能低，本例将sampleBuffer转换为CoreImage中的CIImage-性能相对较高且降低代码繁琐度。" class="headerlink" title="原理：由于需要截取相机捕获整个画面其中一部分，所以也就必须拿到那一部分画面的数据，又因为相机AVCaptureVideoDataOutputSampleBufferDelegate中的sampleBuffer为系统私有的数据结构不可直接操作，所以需要将其转换成可以切割的数据结构再进行切割，网上有种思路说将sampleBuffer间接转换为UIImage再对图片切割，这种思路繁琐且性能低，本例将sampleBuffer转换为CoreImage中的CIImage,性能相对较高且降低代码繁琐度。"></a>原理：由于需要截取相机捕获整个画面其中一部分，所以也就必须拿到那一部分画面的数据，又因为相机AVCaptureVideoDataOutputSampleBufferDelegate中的sampleBuffer为系统私有的数据结构不可直接操作，所以需要将其转换成可以切割的数据结构再进行切割，网上有种思路说将sampleBuffer间接转换为UIImage再对图片切割，这种思路繁琐且性能低，本例将sampleBuffer转换为CoreImage中的CIImage,性能相对较高且降低代码繁琐度。</h3><h3 id="最终效果如下，-绿色框中即为截图的画面，长按可以移动。"><a href="#最终效果如下，-绿色框中即为截图的画面，长按可以移动。" class="headerlink" title="最终效果如下， 绿色框中即为截图的画面，长按可以移动。"></a>最终效果如下， 绿色框中即为截图的画面，长按可以移动。</h3><p><img src="http://upload-images.jianshu.io/upload_images/5086522-8dcd2cde5f0b23a3.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="绿色框为截取部分"></p>
<h4 id="GitHub地址-附代码-Crop-sample-buffer"><a href="#GitHub地址-附代码-Crop-sample-buffer" class="headerlink" title="GitHub地址(附代码) : Crop sample buffer"></a>GitHub地址(附代码) : <a href="https://github.com/ChengyangLi/Crop-sample-buffer" target="_blank" rel="noopener">Crop sample buffer</a></h4><h4 id="简书地址-Crop-sample-buffer"><a href="#简书地址-Crop-sample-buffer" class="headerlink" title="简书地址     : Crop sample buffer"></a>简书地址     : <a href="http://www.jianshu.com/p/ac79a80f1af2" target="_blank" rel="noopener">Crop sample buffer</a></h4><h4 id="博客地址-Crop-sample-buffer"><a href="#博客地址-Crop-sample-buffer" class="headerlink" title="博客地址     : Crop sample buffer"></a>博客地址     : <a href="https://chengyangli.github.io/2017/07/12/cropSampleBuffer/" target="_blank" rel="noopener">Crop sample buffer</a></h4><h4 id="掘金地址-Crop-sample-buffer"><a href="#掘金地址-Crop-sample-buffer" class="headerlink" title="掘金地址     : Crop sample buffer"></a>掘金地址     : <a href="https://juejin.im/post/5a8fe2a66fb9a063317c6828" target="_blank" rel="noopener">Crop sample buffer</a></h4><h2 id="注意：使用ARC与MRC下代码有所区别，已经在项目中标注好，主要为管理全局的CIContext对象，它在初始化的方法中编译器没有对其进行retain-所以，调用会报错。"><a href="#注意：使用ARC与MRC下代码有所区别，已经在项目中标注好，主要为管理全局的CIContext对象，它在初始化的方法中编译器没有对其进行retain-所以，调用会报错。" class="headerlink" title="注意：使用ARC与MRC下代码有所区别，已经在项目中标注好，主要为管理全局的CIContext对象，它在初始化的方法中编译器没有对其进行retain,所以，调用会报错。"></a>注意：使用ARC与MRC下代码有所区别，已经在项目中标注好，主要为管理全局的CIContext对象，它在初始化的方法中编译器没有对其进行retain,所以，调用会报错。</h2><p><img src="http://upload-images.jianshu.io/upload_images/5086522-5f510e448af32d4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cicontextError"></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>本项目中相机捕捉的背景分辨率默认设置为2K（即1920*1080），可切换为4K ,所以需要iPhone 6s以上的设备才支持。</li>
<li>本例可以使用CPU/GPU切割，在VC中需要在cropView初始化前设置isOpenGPU的值，打开则使用GPU,否则CPU</li>
<li>本例只实现了横屏下的Crop功能，本例默认始终为横屏状态，未做竖屏处理。</li>
</ul>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>1.配置相机基本环境(初始化AVCaptureSession，设置代理，开启)，在示例代码中有，这里不再重复。</p>
<p>2.通过AVCaptureVideoDataOutputSampleBufferDelegate代理中拿到原始画面数据(CMSampleBufferRef)进行处理</p>
<h2 id="实现途径"><a href="#实现途径" class="headerlink" title="实现途径"></a>实现途径</h2><h3 id="1-利用CPU软件截取-CPU进行计算并切割，消耗性能较大"><a href="#1-利用CPU软件截取-CPU进行计算并切割，消耗性能较大" class="headerlink" title="1.利用CPU软件截取(CPU进行计算并切割，消耗性能较大)"></a>1.利用CPU软件截取(CPU进行计算并切割，消耗性能较大)</h3><ul>
<li>(CMSampleBufferRef)cropSampleBufferBySoftware:(CMSampleBufferRef)sampleBuffer；</li>
</ul>
<h3 id="2-利用-硬件截取-利用Apple官方公开的方法利用硬件进行切割，性能较好，-但仍有问题待解决"><a href="#2-利用-硬件截取-利用Apple官方公开的方法利用硬件进行切割，性能较好，-但仍有问题待解决" class="headerlink" title="2.利用 硬件截取(利用Apple官方公开的方法利用硬件进行切割，性能较好， 但仍有问题待解决)"></a>2.利用 硬件截取(利用Apple官方公开的方法利用硬件进行切割，性能较好， 但仍有问题待解决)</h3><ul>
<li>(CMSampleBufferRef)cropSampleBufferByHardware:(CMSampleBufferRef)buffer；</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Called whenever an AVCaptureVideoDataOutput instance outputs a new video frame. 每产生一帧视频帧时调用一次</span><br><span class="line">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123;</span><br><span class="line">    CMSampleBufferRef cropSampleBuffer;</span><br><span class="line">    </span><br><span class="line">#warning 两种切割方式任选其一，GPU切割性能较好，CPU切割取决于设备，一般时间长会掉帧。</span><br><span class="line">    if (self.isOpenGPU) &#123;</span><br><span class="line">         cropSampleBuffer = [self.cropView cropSampleBufferByHardware:sampleBuffer];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">         cropSampleBuffer = [self.cropView cropSampleBufferBySoftware:sampleBuffer];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 使用完后必须显式release，不在iOS自动回收范围</span><br><span class="line">    CFRelease(cropSampleBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以上方法为每产生一帧视频帧时调用一次的相机代理，其中sampleBuffer为每帧画面的原始数据，需要对原始数据进行切割处理方可达到本例需求。注意最后一定要对cropSampleBuffer进行release避免内存溢出而发生闪退。</li>
</ul>
<h2 id="利用CPU截取"><a href="#利用CPU截取" class="headerlink" title="利用CPU截取"></a>利用CPU截取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">- (CMSampleBufferRef)cropSampleBufferBySoftware:(CMSampleBufferRef)sampleBuffer &#123;</span><br><span class="line">    OSStatus status;</span><br><span class="line">    </span><br><span class="line">    //    CVPixelBufferRef pixelBuffer = [self modifyImage:buffer];</span><br><span class="line">    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);</span><br><span class="line">    // Lock the image buffer</span><br><span class="line">    CVPixelBufferLockBaseAddress(imageBuffer,0);</span><br><span class="line">    // Get information about the image</span><br><span class="line">    uint8_t *baseAddress     = (uint8_t *)CVPixelBufferGetBaseAddress(imageBuffer);</span><br><span class="line">    size_t  bytesPerRow      = CVPixelBufferGetBytesPerRow(imageBuffer);</span><br><span class="line">    size_t  width            = CVPixelBufferGetWidth(imageBuffer);</span><br><span class="line">    // size_t  height           = CVPixelBufferGetHeight(imageBuffer);</span><br><span class="line">    NSInteger bytesPerPixel  =  bytesPerRow/width;</span><br><span class="line">    </span><br><span class="line">    // YUV 420 Rule</span><br><span class="line">    if (_cropX % 2 != 0) _cropX += 1;</span><br><span class="line">    NSInteger baseAddressStart = _cropY*bytesPerRow+bytesPerPixel*_cropX;</span><br><span class="line">    static NSInteger lastAddressStart = 0;</span><br><span class="line">    lastAddressStart = baseAddressStart;</span><br><span class="line">    </span><br><span class="line">    // pixbuffer 与 videoInfo 只有位置变换或者切换分辨率或者相机重启时需要更新，其余情况不需要，Demo里只写了位置更新，其余情况自行添加</span><br><span class="line">    // NSLog(@&quot;demon pix first : %zu - %zu - %@ - %d - %d - %d -%d&quot;,width, height, self.currentResolution,_cropX,_cropY,self.currentResolutionW,self.currentResolutionH);</span><br><span class="line">    static CVPixelBufferRef            pixbuffer = NULL;</span><br><span class="line">    static CMVideoFormatDescriptionRef videoInfo = NULL;</span><br><span class="line">    </span><br><span class="line">    // x,y changed need to reset pixbuffer and videoinfo</span><br><span class="line">    if (lastAddressStart != baseAddressStart) &#123;</span><br><span class="line">        if (pixbuffer != NULL) &#123;</span><br><span class="line">            CVPixelBufferRelease(pixbuffer);</span><br><span class="line">            pixbuffer = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (videoInfo != NULL) &#123;</span><br><span class="line">            CFRelease(videoInfo);</span><br><span class="line">            videoInfo = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (pixbuffer == NULL) &#123;</span><br><span class="line">        NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:</span><br><span class="line">                                 [NSNumber numberWithBool : YES],           kCVPixelBufferCGImageCompatibilityKey,</span><br><span class="line">                                 [NSNumber numberWithBool : YES],           kCVPixelBufferCGBitmapContextCompatibilityKey,</span><br><span class="line">                                 [NSNumber numberWithInt  : g_width_size],  kCVPixelBufferWidthKey,</span><br><span class="line">                                 [NSNumber numberWithInt  : g_height_size], kCVPixelBufferHeightKey,</span><br><span class="line">                                 nil];</span><br><span class="line">        </span><br><span class="line">        status = CVPixelBufferCreateWithBytes(kCFAllocatorDefault, g_width_size, g_height_size, kCVPixelFormatType_32BGRA, &amp;baseAddress[baseAddressStart], bytesPerRow, NULL, NULL, (__bridge CFDictionaryRef)options, &amp;pixbuffer);</span><br><span class="line">        if (status != 0) &#123;</span><br><span class="line">            NSLog(@&quot;Crop CVPixelBufferCreateWithBytes error %d&quot;,(int)status);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CVPixelBufferUnlockBaseAddress(imageBuffer,0);</span><br><span class="line">    </span><br><span class="line">    CMSampleTimingInfo sampleTime = &#123;</span><br><span class="line">        .duration               = CMSampleBufferGetDuration(sampleBuffer),</span><br><span class="line">        .presentationTimeStamp  = CMSampleBufferGetPresentationTimeStamp(sampleBuffer),</span><br><span class="line">        .decodeTimeStamp        = CMSampleBufferGetDecodeTimeStamp(sampleBuffer)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    if (videoInfo == NULL) &#123;</span><br><span class="line">        status = CMVideoFormatDescriptionCreateForImageBuffer(kCFAllocatorDefault, pixbuffer, &amp;videoInfo);</span><br><span class="line">        if (status != 0) NSLog(@&quot;Crop CMVideoFormatDescriptionCreateForImageBuffer error %d&quot;,(int)status);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CMSampleBufferRef cropBuffer = NULL;</span><br><span class="line">    status = CMSampleBufferCreateForImageBuffer(kCFAllocatorDefault, pixbuffer, true, NULL, NULL, videoInfo, &amp;sampleTime, &amp;cropBuffer);</span><br><span class="line">    if (status != 0) NSLog(@&quot;Crop CMSampleBufferCreateForImageBuffer error %d&quot;,(int)status);</span><br><span class="line">    </span><br><span class="line">    lastAddressStart = baseAddressStart;</span><br><span class="line">    </span><br><span class="line">    return cropBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以上方法为切割sampleBuffer的对象方法<br>  首先从CMSampleBufferRef中提取出CVImageBufferRef数据结构，然后对CVImageBufferRef进行加锁处理，如果要进行页面渲染，需要一个和OpenGL缓冲兼容的图像。用相机API创建的图像已经兼容，您可以马上映射他们进行输入。假设你从已有画面中截取一个新的画面，用作其他处理，你必须创建一种特殊的属性用来创建图像。对于图像的属性必须有Crop宽高， 作为字典的Key.因此创建字典的关键几步不可省略。</li>
</ul>
<blockquote>
<p>位置的计算</p>
</blockquote>
<p>在软切中，我们拿到一帧图片的数据，通过遍历其中的数据确定真正要Crop的位置，利用如下公式可求出具体位置，具体切割原理在[YUV介绍]中有提到，计算时所需的变量在以上代码中均可得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`NSInteger baseAddressStart = _cropY*bytesPerRow+bytesPerPixel*_cropX;</span><br><span class="line">   `</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>1.对X,Y坐标进行校正，因为CVPixelBufferCreateWithBytes是按照像素进行切割，所以需要将点转成像素，再按照比例算出当前位置。即为上述代码的int cropX = (int)(currentResolutionW / kScreenWidth   *  self.cropView.frame.origin.x); currentResolutionW为当前分辨率的宽度，kScreenWidth为屏幕实际宽度。</li>
<li>2.根据YUV 420的规则，每4个Y共用1个UV,而一行有2个Y，所以取点必须按照偶数取点。利用CPU切割中使用的方法为YUV分隔法，具体切割方式请参考<a href="http://www.jianshu.com/p/a91502c00fb0" target="_blank" rel="noopener">YUV介绍</a></li>
<li>3.本例中声明pixelBuffer与videoInfo均为静态变量，为了节省每次创建浪费内存，但是有三种情况需要重置它们：位置变化，分辨率改变，重启相机。文章最后注意详细提到。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// hardware crop</span><br><span class="line">- (CMSampleBufferRef)cropSampleBufferByHardware:(CMSampleBufferRef)buffer &#123;</span><br><span class="line">    // a CMSampleBuffer&apos;s CVImageBuffer of media data.</span><br><span class="line">    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(buffer);</span><br><span class="line">    CGRect           cropRect    = CGRectMake(_cropX, _cropY, g_width_size, g_height_size);</span><br><span class="line">    //        log4cplus_debug(&quot;Crop&quot;, &quot;dropRect x: %f - y : %f - width : %zu - height : %zu&quot;, cropViewX, cropViewY, width, height);</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     First, to render to a texture, you need an image that is compatible with the OpenGL texture cache. Images that were created with the camera API are already compatible and you can immediately map them for inputs. Suppose you want to create an image to render on and later read out for some other processing though. You have to have create the image with a special property. The attributes for the image must have kCVPixelBufferIOSurfacePropertiesKey as one of the keys to the dictionary.</span><br><span class="line">      如果要进行页面渲染，需要一个和OpenGL缓冲兼容的图像。用相机API创建的图像已经兼容，您可以马上映射他们进行输入。假设你从已有画面中截取一个新的画面，用作其他处理，你必须创建一种特殊的属性用来创建图像。对于图像的属性必须有kCVPixelBufferIOSurfacePropertiesKey 作为字典的Key.因此以下步骤不可省略</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    OSStatus status;</span><br><span class="line">    </span><br><span class="line">    /* Only resolution has changed we need to reset pixBuffer and videoInfo so that reduce calculate count */</span><br><span class="line">    static CVPixelBufferRef            pixbuffer = NULL;</span><br><span class="line">    static CMVideoFormatDescriptionRef videoInfo = NULL;</span><br><span class="line">    </span><br><span class="line">    if (pixbuffer == NULL) &#123;</span><br><span class="line">        NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:</span><br><span class="line">                                 [NSNumber numberWithInt:g_width_size],     kCVPixelBufferWidthKey,</span><br><span class="line">                                 [NSNumber numberWithInt:g_height_size],    kCVPixelBufferHeightKey, nil];</span><br><span class="line">        status = CVPixelBufferCreate(kCFAllocatorSystemDefault, g_width_size, g_height_size, kCVPixelFormatType_420YpCbCr8BiPlanarFullRange, (__bridge CFDictionaryRef)options, &amp;pixbuffer);</span><br><span class="line">        // ensures that the CVPixelBuffer is accessible in system memory. This should only be called if the base address is going to be used and the pixel data will be accessed by the CPU</span><br><span class="line">        if (status != noErr) &#123;</span><br><span class="line">            NSLog(@&quot;Crop CVPixelBufferCreate error %d&quot;,(int)status);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CIImage *ciImage = [CIImage imageWithCVImageBuffer:imageBuffer];</span><br><span class="line">    ciImage = [ciImage imageByCroppingToRect:cropRect];</span><br><span class="line">    // Ciimage get real image is not in the original point  after excute crop. So we need to pan.</span><br><span class="line">    ciImage = [ciImage imageByApplyingTransform:CGAffineTransformMakeTranslation(-_cropX, -_cropY)];</span><br><span class="line">    </span><br><span class="line">    static CIContext *ciContext = nil;</span><br><span class="line">    if (ciContext == nil) &#123;</span><br><span class="line">        //        NSMutableDictionary *options = [[NSMutableDictionary alloc] init];</span><br><span class="line">        //        [options setObject:[NSNull null] forKey:kCIContextWorkingColorSpace];</span><br><span class="line">        //        [options setObject:@0            forKey:kCIContextUseSoftwareRenderer];</span><br><span class="line">        EAGLContext *eaglContext = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</span><br><span class="line">        ciContext = [CIContext contextWithEAGLContext:eaglContext options:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    [ciContext render:ciImage toCVPixelBuffer:pixbuffer];</span><br><span class="line">    //    [ciContext render:ciImage toCVPixelBuffer:pixbuffer bounds:cropRect colorSpace:nil];</span><br><span class="line">    </span><br><span class="line">    CMSampleTimingInfo sampleTime = &#123;</span><br><span class="line">        .duration               = CMSampleBufferGetDuration(buffer),</span><br><span class="line">        .presentationTimeStamp  = CMSampleBufferGetPresentationTimeStamp(buffer),</span><br><span class="line">        .decodeTimeStamp        = CMSampleBufferGetDecodeTimeStamp(buffer)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    if (videoInfo == NULL) &#123;</span><br><span class="line">        status = CMVideoFormatDescriptionCreateForImageBuffer(kCFAllocatorDefault, pixbuffer, &amp;videoInfo);</span><br><span class="line">        if (status != 0) NSLog(@&quot;Crop CMVideoFormatDescriptionCreateForImageBuffer error %d&quot;,(int)status);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CMSampleBufferRef cropBuffer;</span><br><span class="line">    status = CMSampleBufferCreateForImageBuffer(kCFAllocatorDefault, pixbuffer, true, NULL, NULL, videoInfo, &amp;sampleTime, &amp;cropBuffer);</span><br><span class="line">    if (status != 0) NSLog(@&quot;Crop CMSampleBufferCreateForImageBuffer error %d&quot;,(int)status);</span><br><span class="line">    </span><br><span class="line">    return cropBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以上为硬件切割的方法，硬件切割利用GPU进行切割，主要利用CoreImage中CIContext 对象进行渲染。</p>
</li>
<li><p>CoreImage and UIKit coordinates （CoreImage 与 UIKit坐标系问题）：我在开始做的时候跟正常一样用设定的位置对图像进行切割，但是发现，切出来的位置不对，通过上网查阅发现一个有趣的现象CoreImage 与 UIKit坐标系不相同<br>如下图：<br>正常UIKit坐标系是以左上角为原点：</p>
</li>
</ul>
<p><img src="https://cl.ly/0O070Z391Y3m/Snip20170802_2.png" alt=""></p>
<p>而CoreImage坐标系是以左下角为原点：（在CoreImage中，每个图像的坐标系是独立于设备的）</p>
<p><img src="https://cl.ly/1B3X230y0l1m/Snip20170802_1.png" alt=""></p>
<p>所以切割的时候一定要注意转换Y，X的位置是正确的，Y是相反的。</p>
<ul>
<li>如果要进行页面渲染，需要一个和OpenGL缓冲兼容的图像。用相机API创建的图像已经兼容，您可以马上映射他们进行输入。假设你从已有画面中截取一个新的画面，用作其他处理，你必须创建一种特殊的属性用来创建图像。对于图像的属性必须有宽高 作为字典的Key.因此创建字典的关键几步不可省略。</li>
<li>对CoreImage进行切割有两种切割的方法均可用：<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 2. 或者直接使用： ```  [ciContext render:ciImage toCVPixelBuffer:pixelBuffer bounds:cropRect colorSpace:nil]; ``` </span><br><span class="line">- 注意：CIContext 中包含图像大量上下文信息，不能在回调中多次调用，官方建议只初始化一次。但是注意ARC,MRC区别。</span><br><span class="line"></span><br><span class="line">### 注意：</span><br><span class="line">##### 1. 使用ARC与MRC下代码有所区别，已经在项目中标注好，主要为管理全局的CIContext对象，它在初始化的方法中编译器没有对其进行retain,所以，调用会报错。</span><br><span class="line">![cicontextError](http://upload-images.jianshu.io/upload_images/5086522-5f510e448af32d4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">##### 2.切换前后置摄像头：因为不同机型的前后置摄像头差别较大，一种处理手段是在记录iphone机型crop的plist文件中增加前后置摄像头支持分辨率的属性，然后在代码中根据plist映射出来的模型进行分别引用。另一种方案是做自动降级处理，例如后置支持2K，前置支持720P,则转换后检测到前置不支持2K就自动将前置降低一个等级，直到找到需要的等级。如果这样操作处理逻辑较多且初看不易理解，而前置切割功能适用范围不大，所以暂时只支持后置切割。</span><br><span class="line"></span><br><span class="line">### 补充说明</span><br><span class="line">- 屏幕逻辑分辨率与视频分辨率</span><br><span class="line"></span><br><span class="line">1. Point and pixel的区别</span><br><span class="line">因为此类说明网上很多，这里就不做太多具体阐述，仅仅简述一下</span><br><span class="line">Point 即是设备的逻辑分辨率，即[UIScreen mainScreen].bounds.size.width 得到的设备的宽高，所以点可以简单理解为iOS开发中的坐标系，方便对界面元素进行描述。</span><br><span class="line"></span><br><span class="line">2. Pixel: 像素则是比点更精确的单位，在普通屏中1点=1像素，Retina屏中1点=2像素。</span><br><span class="line"></span><br><span class="line">3. 分辨率 分辨率需要根据不同机型所支持的最大分辨率进行设置，例如iPhone 6S以上机型支持4k(3840 * 2160)分辨率拍摄视频。而当我们进行Crop操作的时候调用的API正是通过像素来进行切割，所以我们操作的单位是pixel而不是point.下面会有详细介绍。</span><br><span class="line"></span><br><span class="line">- ARC, MRC下所做工作不同</span><br><span class="line"></span><br><span class="line">&gt; CIContext 的初始化</span><br><span class="line"></span><br><span class="line">首先应该将CIContext声明为全局变量或静态变量，因为CIContext初始化一次内部含有大量信息，比较耗内存，且只是渲染的时候使用，无需每次都初始化，然后如下如果在MRC中初始化完成后并未对ciContext发出retain的消息，所以需要手动retain,但在ARC下系统会自动完成此操作。</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>ARC:</p>
<p>static CIContext *ciContext = NULL;<br>ciContext = [CIContext contextWithOptions:nil];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>MRC:</p>
<p>static CIContext *ciContext = NULL;<br>ciContext = [CIContext contextWithOptions:nil];<br>[ciContext retain];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 坐标问题</span><br><span class="line"></span><br><span class="line">#####1. 理解点与像素的对应关系</span><br><span class="line">首先CropView需要在手机显示出来，所以坐标系还是UIKit的坐标系，左上角为原点，宽高分别为不同手机的宽高(如iPhone8 : 375*667, iPhone8P : 414 * 736, iPhoneX : 375 * 816),但是我们需要算出实际分辨率下CropView的坐标，即我们可以把当前获取的cropView的x,y点的位置转换成对应pixel的位置。</span><br></pre></td></tr></table></figure></p>
<p>// 注意这里求的是X的像素坐标，以iPhone 8 为例 （点为375 <em> 667），分辨率为(1920 </em> 1080)<br>_cropX  = (int)(_currentResolutionW / _screenWidth  <em> (cropView.frame.origin.x);<br>即<br>_cropX  = (int)(1920 / 375  </em> 当前cropView的x点坐标;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#####2. CPU / GPU 两种方式切割时坐标系的位置不同</span><br><span class="line">&gt; 原点位置</span><br><span class="line"></span><br><span class="line">CPU : UIKit为坐标系，原点在左上角</span><br><span class="line"></span><br><span class="line">GPU : CoreImage为坐标系，原点在左下角</span><br><span class="line"></span><br><span class="line">##### 因此计算时如果使用GPU, y的坐标是相反的，我们需要通过如下公式转换，即将点对应转为正常以左上角为原点坐标系中的点。</span><br></pre></td></tr></table></figure></p>
<p>_cropY  = (int)(_currentResolutionH / _screenHeight * (_screenHeight - self.frame.origin.y  -  self.frame.size.height));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#####3. 当手机屏幕不是16:9时，如果将视频设置为填充满屏幕则会出现偏差</span><br><span class="line"></span><br><span class="line">需要注意的是，因为部分手机或iPad屏幕尺寸并不为16:9(iPhone X, 所有iPad (4 : 3)),如果我们在2k(1920 * 1080) , 4k (3840 * 2160 ) 分辨率下对显示的View设置了 `captureVideoPreviewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill;` 那么屏幕会牺牲一部分视频填充视图，即相机捕获的视频数据并没有完整展现在手机视图里，所以再使用我们的crop功能时，由于我们使用的是UIKit的坐标系，也就是说原点（0,0）并不是该帧图片真正像素的(0,0)，而如果计算则需要写很多额外代码，所以我们可以在Crop功能下设置`captureVideoPreviewLayer.videoGravity = AVLayerVideoGravityResizeAspect;` 这样的话video视图会根据分辨率调整为显示完整视频。但是设置后如果设备是iPhoneX (比例大于16:9,X轴会缩小，黑边填充),iPad(比例小于16:9，y轴缩小，黑边填充)。</span><br><span class="line"></span><br><span class="line">##### 按照如上解析，我们之前计算的点会出现偏差，因为相当于x或y轴会缩小一部分，而我们拿到的cropView的坐标仍然是相对于整个父View而言。</span><br><span class="line"></span><br><span class="line">这时，如果我们通过不断更改cropView则代码量较大，所以我在这里定义了一个videoRect属性用来记录Video真正的Rect,因为当程序运行时我们可以得到屏幕宽高比例，所以通过确定宽高比可以拿到真正Video的rect,此时在后续代码中我们只需要传入videoRect的尺寸进行计算，即时是原先正常16:9的手机后面API也无须更改。</span><br><span class="line"> </span><br><span class="line">#####4. 为什么用int</span><br><span class="line"> 在软切中，我们在创建pixelBuffer时需要使用</span><br></pre></td></tr></table></figure></p>
<p> CV_EXPORT CVReturn CVPixelBufferCreateWithBytes(<br>    CFAllocatorRef CV_NULLABLE allocator,<br>    size_t width,<br>    size_t height,<br>    OSType pixelFormatType,<br>    void <em> CV_NONNULL baseAddress,<br>    size_t bytesPerRow,<br>    CVPixelBufferReleaseBytesCallback CV_NULLABLE releaseCallback,<br>    void </em> CV_NULLABLE releaseRefCon,<br>    CFDictionaryRef CV_NULLABLE pixelBufferAttributes,<br>    CV_RETURNS_RETAINED_PARAMETER CVPixelBufferRef CV_NULLABLE <em> CV_NONNULL pixelBufferOut)<br><code>`</code><br>这个API,我们需要将x,y的点放入baseAddress中，这里又需要使用公式` NSInteger baseAddressStart = _cropY</em>bytesPerRow+bytesPerPixel*_cropX; <code>,但是这里根据YUV 420的规则我们我们传入的X的点不能为奇数，所以我们需要</code>if (_cropX % 2 != 0) _cropX += 1;`，而只有整型才能求余，所以这里的点我们均定义为int,在视图展示中忽略小数点的误差。</p>
<h3 id="TODO-："><a href="#TODO-：" class="headerlink" title="TODO ："></a>TODO ：</h3><h5 id="在硬件切割-GPU-的过程中发现-ciContext-render-ciImage-toCVPixelBuffer-pixelBuffer-渲染时间不断增加，导致掉帧，而ciContext只初始化一次，并未发生内存泄露，如果input-resolution-为-2k-切割720P-在7plus上性能较好，其他机型和尺寸则掉帧严重。而软件切割-CPU-虽然CPU使用率相比GPU提高15-左右但是性能相对稳定，掉帧也只有在长时间直播后偶尔发生，但是CPU使用率较高。"><a href="#在硬件切割-GPU-的过程中发现-ciContext-render-ciImage-toCVPixelBuffer-pixelBuffer-渲染时间不断增加，导致掉帧，而ciContext只初始化一次，并未发生内存泄露，如果input-resolution-为-2k-切割720P-在7plus上性能较好，其他机型和尺寸则掉帧严重。而软件切割-CPU-虽然CPU使用率相比GPU提高15-左右但是性能相对稳定，掉帧也只有在长时间直播后偶尔发生，但是CPU使用率较高。" class="headerlink" title="在硬件切割(GPU)的过程中发现 [ciContext render:ciImage toCVPixelBuffer:pixelBuffer]; 渲染时间不断增加，导致掉帧，而ciContext只初始化一次，并未发生内存泄露，如果input resolution 为 2k, 切割720P 在7plus上性能较好，其他机型和尺寸则掉帧严重。而软件切割(CPU)虽然CPU使用率相比GPU提高15%左右但是性能相对稳定，掉帧也只有在长时间直播后偶尔发生，但是CPU使用率较高。"></a>在硬件切割(GPU)的过程中发现 [ciContext render:ciImage toCVPixelBuffer:pixelBuffer]; 渲染时间不断增加，导致掉帧，而ciContext只初始化一次，并未发生内存泄露，如果input resolution 为 2k, 切割720P 在7plus上性能较好，其他机型和尺寸则掉帧严重。而软件切割(CPU)虽然CPU使用率相比GPU提高15%左右但是性能相对稳定，掉帧也只有在长时间直播后偶尔发生，但是CPU使用率较高。</h5>
      
    </div>

    

    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>穷则github点星,达可兼济本人</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="小东邪 - Demon WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="小东邪 - Demon Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/视频-Video/" rel="tag"># 视频(Video)</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/23/record/" rel="next" title="Audio -- PCM to AAC">
                <i class="fa fa-chevron-left"></i> Audio -- PCM to AAC
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/23/H264H265Encoder/" rel="prev" title="H264,H265 Encoder">
                H264,H265 Encoder <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
        <div onclick="showGitment()" id="gitment_title" class="gitment_title">显示 Gitment 评论</div>
        <div id="container" style="display:none"></div>
        <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
        <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
        <script>
        const myTheme = {
          render(state, instance) {
            const container = document.createElement('div');
            container.lang = "en-US";
            container.className = 'gitment-container gitment-root-container';
            container.appendChild(instance.renderHeader(state, instance));
            container.appendChild(instance.renderEditor(state, instance));
            container.appendChild(instance.renderComments(state, instance));
            container.appendChild(instance.renderFooter(state, instance));
            return container;
          }
        }
        function showGitment() {
          $("#gitment_title").attr("style", "display:none");
          $("#container").attr("style", "").addClass("gitment_container");
          var gitment = new Gitment({
            id: window.location.pathname,
            theme: myTheme,
            owner: '',
            repo: '',
            oauth: {
              client_id: 'c209d8cfa2d7f7696f17',
              client_secret: '1681a33c8745e7a79871dfc6613170a03c44fed8'
            }
          });
          gitment.render('container');
        }
        </script>

  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/yzeIpXHXXaOcxOnovNgST0jvIeuupEGzPfZ3DWoYrLY!/r/dFQBAAAAAAAA"
                alt="小东邪 - Demon" />
            
              <p class="site-author-name" itemprop="name">小东邪 - Demon</p>
              <p class="site-description motion-element" itemprop="description">一生负气成今日，四海无人对夕阳.</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/XiaoDongXie1024" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/23f3ec991fed" target="_blank" title="简书"><i class="fa fa-fw fa-book"></i>简书</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://juejin.im/user/58ec343861ff4b00691b4f26" target="_blank" title="掘金"><i class="fa fa-fw fa-star"></i>掘金</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS开发中截取相机部分画面，切割sampleBuffer（Crop-sample-buffer）"><span class="nav-number">1.</span> <span class="nav-text">iOS开发中截取相机部分画面，切割sampleBuffer（Crop sample buffer）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本例需求：在类似直播的功能界面-二维码扫描，人脸识别或其他需求中的功能界面或其他需求中需要从相机捕获的画面中单独截取出一部分区域。"><span class="nav-number">1.1.</span> <span class="nav-text">本例需求：在类似直播的功能界面,二维码扫描，人脸识别或其他需求中的功能界面或其他需求中需要从相机捕获的画面中单独截取出一部分区域。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原理：由于需要截取相机捕获整个画面其中一部分，所以也就必须拿到那一部分画面的数据，又因为相机AVCaptureVideoDataOutputSampleBufferDelegate中的sampleBuffer为系统私有的数据结构不可直接操作，所以需要将其转换成可以切割的数据结构再进行切割，网上有种思路说将sampleBuffer间接转换为UIImage再对图片切割，这种思路繁琐且性能低，本例将sampleBuffer转换为CoreImage中的CIImage-性能相对较高且降低代码繁琐度。"><span class="nav-number">1.2.</span> <span class="nav-text">原理：由于需要截取相机捕获整个画面其中一部分，所以也就必须拿到那一部分画面的数据，又因为相机AVCaptureVideoDataOutputSampleBufferDelegate中的sampleBuffer为系统私有的数据结构不可直接操作，所以需要将其转换成可以切割的数据结构再进行切割，网上有种思路说将sampleBuffer间接转换为UIImage再对图片切割，这种思路繁琐且性能低，本例将sampleBuffer转换为CoreImage中的CIImage,性能相对较高且降低代码繁琐度。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最终效果如下，-绿色框中即为截图的画面，长按可以移动。"><span class="nav-number">1.3.</span> <span class="nav-text">最终效果如下， 绿色框中即为截图的画面，长按可以移动。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GitHub地址-附代码-Crop-sample-buffer"><span class="nav-number">1.3.1.</span> <span class="nav-text">GitHub地址(附代码) : Crop sample buffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简书地址-Crop-sample-buffer"><span class="nav-number">1.3.2.</span> <span class="nav-text">简书地址     : Crop sample buffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#博客地址-Crop-sample-buffer"><span class="nav-number">1.3.3.</span> <span class="nav-text">博客地址     : Crop sample buffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#掘金地址-Crop-sample-buffer"><span class="nav-number">1.3.4.</span> <span class="nav-text">掘金地址     : Crop sample buffer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意：使用ARC与MRC下代码有所区别，已经在项目中标注好，主要为管理全局的CIContext对象，它在初始化的方法中编译器没有对其进行retain-所以，调用会报错。"><span class="nav-number">2.</span> <span class="nav-text">注意：使用ARC与MRC下代码有所区别，已经在项目中标注好，主要为管理全局的CIContext对象，它在初始化的方法中编译器没有对其进行retain,所以，调用会报错。</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景"><span class="nav-number">2.1.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本配置"><span class="nav-number">3.</span> <span class="nav-text">基本配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现途径"><span class="nav-number">4.</span> <span class="nav-text">实现途径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-利用CPU软件截取-CPU进行计算并切割，消耗性能较大"><span class="nav-number">4.1.</span> <span class="nav-text">1.利用CPU软件截取(CPU进行计算并切割，消耗性能较大)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-利用-硬件截取-利用Apple官方公开的方法利用硬件进行切割，性能较好，-但仍有问题待解决"><span class="nav-number">4.2.</span> <span class="nav-text">2.利用 硬件截取(利用Apple官方公开的方法利用硬件进行切割，性能较好， 但仍有问题待解决)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析"><span class="nav-number">4.3.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用CPU截取"><span class="nav-number">5.</span> <span class="nav-text">利用CPU截取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TODO-："><span class="nav-number">5.1.</span> <span class="nav-text">TODO ：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在硬件切割-GPU-的过程中发现-ciContext-render-ciImage-toCVPixelBuffer-pixelBuffer-渲染时间不断增加，导致掉帧，而ciContext只初始化一次，并未发生内存泄露，如果input-resolution-为-2k-切割720P-在7plus上性能较好，其他机型和尺寸则掉帧严重。而软件切割-CPU-虽然CPU使用率相比GPU提高15-左右但是性能相对稳定，掉帧也只有在长时间直播后偶尔发生，但是CPU使用率较高。"><span class="nav-number">5.1.0.1.</span> <span class="nav-text">在硬件切割(GPU)的过程中发现 [ciContext render:ciImage toCVPixelBuffer:pixelBuffer]; 渲染时间不断增加，导致掉帧，而ciContext只初始化一次，并未发生内存泄露，如果input resolution 为 2k, 切割720P 在7plus上性能较好，其他机型和尺寸则掉帧严重。而软件切割(CPU)虽然CPU使用率相比GPU提高15%左右但是性能相对稳定，掉帧也只有在长时间直播后偶尔发生，但是CPU使用率较高。</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小东邪 - Demon</span>

  

  
</div>








  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.4.2</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="Total Visitors">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="Total Views">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname,
            owner: 'XiaoDongXie1024',
            repo: 'gitment-comments',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '1681a33c8745e7a79871dfc6613170a03c44fed8',
            
                client_id: 'c209d8cfa2d7f7696f17'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    






  





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! See more at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see here how to solve it: https://github.com/theme-next/hexo-leancloud-counter-security. \n But you also can use LeanCloud without security, by set \'security\' option to \'false\'.');
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "",
                'X-LC-Key': "",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  

  

  

  

  

</body>
</html>
