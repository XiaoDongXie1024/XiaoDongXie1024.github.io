<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.4.2">


  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=6.4.2" color="#222">



  <meta name="msapplication-config" content="/images/browserconfig.xml">







<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="本文需求：使用H264, H265实现视频数据的编码并录制开始200帧存为文件.">
<meta name="keywords" content="H264, H265, Encoder, HEVC">
<meta property="og:type" content="article">
<meta property="og:title" content="H264,H265 Encoder">
<meta property="og:url" content="https://XiaoDongXie1024.github.io/2018/10/26/H264H265Encoder/index.html">
<meta property="og:site_name" content="小东邪 Show Time">
<meta property="og:description" content="本文需求：使用H264, H265实现视频数据的编码并录制开始200帧存为文件.">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/Zs.FQtSqK3HEAV0KwhBWsd11gDVDBOGc6C8nEvLWvbI!/r/dLEAAAAAAAAA">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/0laaTVE7fYiJysspAOooBZ3fCdWlUxVfVNz66tO2jv4!/r/dBABAAAAAAAA">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/KExDsa2RJzGpe6a9NBTKJClrkX3HpcT68p2i4pqoJyY!/r/dOAAAAAAAAAA">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/yuYb34e.S.4UoETVIJDPI1L6DYdVGdlKfW80wULI.T8!/r/dHYBAAAAAAAA">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/YUsq7p4oq0E8Uvz5hYxFAxH2pA.NoV38kiwjRwYjtZY!/r/dGwBAAAAAAAA">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/6LWUuXOk2xoelipoT3Lbu6qJQDTfOemFXg55YP1dh.U!/r/dDwBAAAAAAAA">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/dLoOAI2WwVn2yGsmI0W3nqkRQplUQzK0w5gl99vUYkU!/r/dOAAAAAAAAAA">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/wNFEFe7Lz7M5qCeNJNPrrSwyQjJdG3.J75X1vkszvn8!/r/dCsAAAAAAAAA">
<meta property="og:updated_time" content="2018-10-26T01:16:48.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="H264,H265 Encoder">
<meta name="twitter:description" content="本文需求：使用H264, H265实现视频数据的编码并录制开始200帧存为文件.">
<meta name="twitter:image" content="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/Zs.FQtSqK3HEAV0KwhBWsd11gDVDBOGc6C8nEvLWvbI!/r/dLEAAAAAAAAA">






  <link rel="canonical" href="https://XiaoDongXie1024.github.io/2018/10/26/H264H265Encoder/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>H264,H265 Encoder | 小东邪 Show Time</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小东邪 Show Time</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-桃花岛">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>桃花岛</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-时间轴">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>时间轴</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-武功秘籍">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>武功秘籍</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-江湖地位">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>江湖地位</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-江湖历程">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-futbol-o"></i> <br>江湖历程</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://XiaoDongXie1024.github.io/2018/10/26/H264H265Encoder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小东邪 - Demon">
      <meta itemprop="description" content="一生负气成今日，四海无人对夕阳.">
      <meta itemprop="image" content="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/yzeIpXHXXaOcxOnovNgST0jvIeuupEGzPfZ3DWoYrLY!/r/dFQBAAAAAAAA">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小东邪 Show Time">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">H264,H265 Encoder
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-10-26 09:16:48" itemprop="dateCreated datePublished" datetime="2018-10-26T09:16:48+08:00">2018-10-26</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/编解码-Encode-Decode/" itemprop="url" rel="index"><span itemprop="name">编解码(Encode/Decode)</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/26/H264H265Encoder/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">Comments: </span> <span class="post-comments-count gitment-comments-count" data-xid="/2018/10/26/H264H265Encoder/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/10/26/H264H265Encoder/" class="leancloud_visitors" data-flag-title="H264,H265 Encoder">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Views: </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             Views:  
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          
              <div class="post-description">本文需求：使用H264, H265实现视频数据的编码并录制开始200帧存为文件.</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p class="description"></p>

<a id="more"></a>
<h3 id="——————————————————–"><a href="#——————————————————–" class="headerlink" title="——————————————————–"></a>——————————————————–</h3><h3 id="本例需求：使用H264-H265实现视频数据的编码并录制开始200帧存为文件"><a href="#本例需求：使用H264-H265实现视频数据的编码并录制开始200帧存为文件" class="headerlink" title="本例需求：使用H264, H265实现视频数据的编码并录制开始200帧存为文件."></a>本例需求：使用H264, H265实现视频数据的编码并录制开始200帧存为文件.</h3><h5 id="原理：比如做直播功能，需要将客户端的视频数据传给服务器，如果分辨率过大如2K-4K则传输压力太大，所以需要对视频数据进行编码，传给服务器后再解码以实现大数据量的视频数据的传输，而利用硬件编码则可以极大限度减小CPU压力，当前主流使用H264进行编码，iOS-11-之后，iPhone-7以上的设备可以支持新的编码器H265编码器，使得同等质量视频占用的存储空间更小。所以本例中可以使用两种方式实现视频数据的编码"><a href="#原理：比如做直播功能，需要将客户端的视频数据传给服务器，如果分辨率过大如2K-4K则传输压力太大，所以需要对视频数据进行编码，传给服务器后再解码以实现大数据量的视频数据的传输，而利用硬件编码则可以极大限度减小CPU压力，当前主流使用H264进行编码，iOS-11-之后，iPhone-7以上的设备可以支持新的编码器H265编码器，使得同等质量视频占用的存储空间更小。所以本例中可以使用两种方式实现视频数据的编码" class="headerlink" title="原理：比如做直播功能，需要将客户端的视频数据传给服务器，如果分辨率过大如2K,4K则传输压力太大，所以需要对视频数据进行编码，传给服务器后再解码以实现大数据量的视频数据的传输，而利用硬件编码则可以极大限度减小CPU压力，当前主流使用H264进行编码，iOS 11 之后，iPhone 7以上的设备可以支持新的编码器H265编码器，使得同等质量视频占用的存储空间更小。所以本例中可以使用两种方式实现视频数据的编码"></a>原理：比如做直播功能，需要将客户端的视频数据传给服务器，如果分辨率过大如2K,4K则传输压力太大，所以需要对视频数据进行编码，传给服务器后再解码以实现大数据量的视频数据的传输，而利用硬件编码则可以极大限度减小CPU压力，当前主流使用H264进行编码，iOS 11 之后，iPhone 7以上的设备可以支持新的编码器H265编码器，使得同等质量视频占用的存储空间更小。所以本例中可以使用两种方式实现视频数据的编码</h5><h3 id="——————————————————–-1"><a href="#——————————————————–-1" class="headerlink" title="——————————————————–"></a>——————————————————–</h3><h4 id="最终效果如下-：-h264"><a href="#最终效果如下-：-h264" class="headerlink" title="最终效果如下 ： h264"></a>最终效果如下 ： h264</h4><p><img src="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/Zs.FQtSqK3HEAV0KwhBWsd11gDVDBOGc6C8nEvLWvbI!/r/dLEAAAAAAAAA" alt="h264 编码"></p>
<h4 id="h265"><a href="#h265" class="headerlink" title="h265 :"></a>h265 :</h4><p><img src="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/0laaTVE7fYiJysspAOooBZ3fCdWlUxVfVNz66tO2jv4!/r/dBABAAAAAAAA" alt="h265 编码"></p>
<h3 id="——————————————————–-2"><a href="#——————————————————–-2" class="headerlink" title="——————————————————–"></a>——————————————————–</h3><h4 id="GitHub地址-附代码-H264-H265Encode"><a href="#GitHub地址-附代码-H264-H265Encode" class="headerlink" title="GitHub地址(附代码) : H264,H265Encode"></a>GitHub地址(附代码) : <a href="https://github.com/ChengyangLi/XDXHardwareEncoder" target="_blank" rel="noopener">H264,H265Encode</a></h4><h4 id="简书地址-H264-H265Encode"><a href="#简书地址-H264-H265Encode" class="headerlink" title="简书地址     : H264,H265Encode"></a>简书地址     : <a href="http://www.jianshu.com/p/d783d4a209b6" target="_blank" rel="noopener">H264,H265Encode</a></h4><h4 id="博客地址-H264-H265Encode"><a href="#博客地址-H264-H265Encode" class="headerlink" title="博客地址     : H264,H265Encode"></a>博客地址     : <a href="https://chengyangli.github.io/2017/11/10/H264H265Encoder/" target="_blank" rel="noopener">H264,H265Encode</a></h4><h4 id="掘金地址-https-juejin-im-post-5a8fe3def265da4e8e78781b"><a href="#掘金地址-https-juejin-im-post-5a8fe3def265da4e8e78781b" class="headerlink" title="掘金地址     : https://juejin.im/post/5a8fe3def265da4e8e78781b"></a>掘金地址     : <a href="https://juejin.im/post/5a8fe3def265da4e8e78781b" target="_blank" rel="noopener">https://juejin.im/post/5a8fe3def265da4e8e78781b</a></h4><h3 id="——————————————————–-3"><a href="#——————————————————–-3" class="headerlink" title="——————————————————–"></a>——————————————————–</h3><h2 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h2><h3 id="1-H264-H264是当前主流编码标准，以高压缩高质量和支持多种网络的流媒体传输著称"><a href="#1-H264-H264是当前主流编码标准，以高压缩高质量和支持多种网络的流媒体传输著称" class="headerlink" title="1. H264 : H264是当前主流编码标准，以高压缩高质量和支持多种网络的流媒体传输著称"></a>1. H264 : H264是当前主流编码标准，以高压缩高质量和支持多种网络的流媒体传输著称</h3><h3 id="2-H265-：H264编码器的下一代，它的主要优点提供的压缩比高，相同质量的视频是H264的两倍。"><a href="#2-H265-：H264编码器的下一代，它的主要优点提供的压缩比高，相同质量的视频是H264的两倍。" class="headerlink" title="2. H265 ：H264编码器的下一代，它的主要优点提供的压缩比高，相同质量的视频是H264的两倍。"></a>2. H265 ：H264编码器的下一代，它的主要优点提供的压缩比高，相同质量的视频是H264的两倍。</h3><h3 id="——————————————————–-4"><a href="#——————————————————–-4" class="headerlink" title="——————————————————–"></a>——————————————————–</h3><h2 id="一-本文需要基本知识点"><a href="#一-本文需要基本知识点" class="headerlink" title="一.本文需要基本知识点"></a>一.本文需要基本知识点</h2><h4 id="注意-可以先通过H264-H265编码器介绍，H264-Data-Structure了解预备知识。"><a href="#注意-可以先通过H264-H265编码器介绍，H264-Data-Structure了解预备知识。" class="headerlink" title="注意:可以先通过H264,H265编码器介绍，H264 Data Structure了解预备知识。"></a>注意:可以先通过<a href="https://chengyangli.github.io/2017/10/15/codec/" target="_blank" rel="noopener">H264,H265编码器介绍</a>，<a href="https://chengyangli.github.io/2017/12/11/h264DataStructure/" target="_blank" rel="noopener">H264 Data Structure</a>了解预备知识。</h4><h4 id="1-软编与硬编概念"><a href="#1-软编与硬编概念" class="headerlink" title="1. 软编与硬编概念"></a>1. 软编与硬编概念</h4><ul>
<li>软编码：使用CPU进行编码。</li>
<li>硬编码：不使用CPU进行编码，使用显卡GPU,专用的DSP、FPGA、ASIC芯片等硬件进行编码。<ul>
<li>比较<ul>
<li>软编码：实现直接、简单，参数调整方便，升级易，但CPU负载重，性能较硬编码低，低码率下质量通常比硬编码要好一点。</li>
<li>性能高，低码率下通常质量低于软编码器，但部分产品在GPU硬件平台移植了优秀的软编码算法（如X264）的，质量基本等同于软编码。</li>
<li>苹果在iOS 8.0系统之前，没有开放系统的硬件编码解码功能，不过Mac OS系统一直有，被称为Video ToolBox的框架来处理硬件的编码和解码，终于在iOS 8.0后，苹果将该框架引入iOS系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-H265优点"><a href="#2-H265优点" class="headerlink" title="2.H265优点"></a>2.H265优点</h4><ul>
<li>压缩比高，在相同图片质量情况下，比JPEG高两倍</li>
<li>能增加如图片的深度信息，透明通道等辅助图片。</li>
<li>支持存放多张图片，类似相册和集合。(实现多重曝光的效果)</li>
<li>支持多张图片实现GIF和livePhoto的动画效果。</li>
<li>无类似JPEG的最大像素限制</li>
<li>支持透明像素</li>
<li>分块加载机制</li>
<li>支持缩略图</li>
</ul>
<h2 id="二-代码解析"><a href="#二-代码解析" class="headerlink" title="二.代码解析"></a>二.代码解析</h2><h4 id="1-实现流程"><a href="#1-实现流程" class="headerlink" title="1.实现流程"></a>1.实现流程</h4><ul>
<li>初始化相机参数，设置相机代理，这里就固定只有竖屏模式。</li>
<li>初始化编码器参数，并启动编码器</li>
<li>在编码成功的回调中从开始录制200帧(文件大小可自行修改)的视频，存到沙盒中，可以通过连接数据线到电脑从itunes中将文件(test0.asf)提取出来</li>
</ul>
<h4 id="2-编码器实现流程"><a href="#2-编码器实现流程" class="headerlink" title="2.编码器实现流程"></a>2.编码器实现流程</h4><ul>
<li>创建编码器需要的session (h264, h265 或同时创建)</li>
<li>设置session属性,如实时编码，码率，fps, 编码的分辨率的宽高，相邻I帧的最大间隔等等<ul>
<li><h6 id="注意H265目前不支持码率的限制"><a href="#注意H265目前不支持码率的限制" class="headerlink" title="注意H265目前不支持码率的限制"></a>注意H265目前不支持码率的限制</h6></li>
</ul>
</li>
<li>当相机回调AVCaptureVideoDataOutputSampleBufferDelegate采集到一帧数据的时候则使用H264/H265编码器对每一帧数据进行编码。</li>
<li>若编码成功会触发回调，回调函数首先检测是否有I帧出现，如果有I帧出现则将sps,pps信息写入否则遍历NALU码流并将startCode替换成{0x00, 0x00, 0x00, 0x01}</li>
</ul>
<h4 id="3-主要方法解析"><a href="#3-主要方法解析" class="headerlink" title="3.主要方法解析"></a>3.主要方法解析</h4><ul>
<li>初始化编码器<br>首先选择使用哪种方式实现，在本例中可以设置[XDXHardwareEncoder getInstance].enableH264 = YES 或者 [XDXHardwareEncoder getInstance].enableH265 = YES，也可以同时设置，如果同时设置需要将其中一个回调函数中的writeFile的方法屏蔽掉，并且只有较新的iPhone(&gt; iPhone8 稳定)才支持同时打开两个session。</li>
</ul>
<blockquote>
<p>判断当前设备是否支持H265编码，必须满足两个条件，一是iPhone 7 以上设备，二是版本大于iOS 11</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">            BOOL hardwareDecodeSupported = VTIsHardwareDecodeSupported(kCMVideoCodecType_HEVC);</span><br><span class="line">            if (hardwareDecodeSupported) &#123;</span><br><span class="line">                _deviceSupportH265 = YES;</span><br><span class="line">                NSLog(@&quot;XDXHardwareEncoder : Support H265 Encode/Decode!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            _deviceSupportH265 = NO;</span><br><span class="line">            NSLog(@&quot;XDXHardwareEncoder : Not support H265 Encode/Decode!&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>系统已经提供VTIsHardwareDecodeSupported判断当前设备是否支持H265编码</p>
<blockquote>
<p>初始化编码器操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">- (void)prepareForEncode &#123;</span><br><span class="line">    if(self.width == 0 || self.height == 0) &#123;</span><br><span class="line">        NSLog(@&quot;XDXHardwareEncoder : VTSession need with and height for init,with = %d,height = %d&quot;,self.width, self.height);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(g_isSupportRealTimeEncoder)  NSLog(@&quot;XDXHardwareEncoder : Device processor is 64 bit&quot;);</span><br><span class="line">    else                            NSLog(@&quot;XDXHardwareEncoder : Device processor is not 64 bit&quot;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;XDXHardwareEncoder : Current h264 open state : %d, h265 open state : %d&quot;,self.enableH264, self.enableH265);</span><br><span class="line">    </span><br><span class="line">    OSStatus h264Status,h265Status;</span><br><span class="line">    BOOL isRestart = NO;</span><br><span class="line">    if (self.enableH264) &#123;</span><br><span class="line">        if (h264CompressionSession != NULL) &#123;</span><br><span class="line">            NSLog(@&quot;XDXHardwareEncoder : H264 session not NULL&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        [m_h264_lock lock];</span><br><span class="line">        NSLog(@&quot;XDXHardwareEncoder : Prepare H264 hardware encoder&quot;);</span><br><span class="line">        </span><br><span class="line">        //[self.delegate willEncoderStart];</span><br><span class="line">        </span><br><span class="line">        self.h264ErrCount = 0;</span><br><span class="line">        </span><br><span class="line">        h264Status = VTCompressionSessionCreate(NULL, self.width, self.height, kCMVideoCodecType_H264, NULL, NULL, NULL, vtCallBack,(__bridge void *)self, &amp;h264CompressionSession);</span><br><span class="line">        if (h264Status != noErr) &#123;</span><br><span class="line">            self.h265ErrCount++;</span><br><span class="line">            NSLog(@&quot;XDXHardwareEncoder : H264 VTCompressionSessionCreate Failed, status = %d&quot;,h264Status);</span><br><span class="line">        &#125;</span><br><span class="line">        [self getSupportedPropertyFlags];</span><br><span class="line">        </span><br><span class="line">        [self applyAllSessionProperty:h264CompressionSession propertyArr:self.h264propertyFlags];</span><br><span class="line">        </span><br><span class="line">        h264Status = VTCompressionSessionPrepareToEncodeFrames(h264CompressionSession);</span><br><span class="line">        if(h264Status != noErr) &#123;</span><br><span class="line">            NSLog(@&quot;XDXHardwareEncoder : H264 VTCompressionSessionPrepareToEncodeFrames Failed, status = %d&quot;,h264Status);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            initializedH264     = true;</span><br><span class="line">            NSLog(@&quot;XDXHardwareEncoder : H264 VTSession create success, with = %d, height = %d, framerate = %d&quot;,self.width,self.height,self.fps);</span><br><span class="line">        &#125;</span><br><span class="line">        if(h264Status != noErr &amp;&amp; self.h264ErrCount != 0) isRestart = YES;</span><br><span class="line">        [m_h264_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.enableH265) &#123;</span><br><span class="line">        if (h265CompressionSession != NULL) &#123;</span><br><span class="line">            NSLog(@&quot;XDXHardwareEncoder : H265 session not NULL&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        [m_h265_lock lock];</span><br><span class="line">        NSLog(@&quot;XDXHardwareEncoder : Prepare h265 hardware encoder&quot;);</span><br><span class="line">        // [self.delegate willEncoderStart];</span><br><span class="line">        </span><br><span class="line">        self.h265ErrCount = 0;</span><br><span class="line">        </span><br><span class="line">        h265Status = VTCompressionSessionCreate(NULL, self.width, self.height, kCMVideoCodecType_HEVC, NULL, NULL, NULL, vtH265CallBack,(__bridge void *)self, &amp;h265CompressionSession);</span><br><span class="line">        if (h265Status != noErr) &#123;</span><br><span class="line">            self.h265ErrCount++;</span><br><span class="line">            NSLog(@&quot;XDXHardwareEncoder : H265 VTCompressionSessionCreate Failed, status = %d&quot;,h265Status);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [self getSupportedPropertyFlags];</span><br><span class="line">        </span><br><span class="line">        [self applyAllSessionProperty:h265CompressionSession propertyArr:self.h265PropertyFlags];</span><br><span class="line">        </span><br><span class="line">        h265Status = VTCompressionSessionPrepareToEncodeFrames(h265CompressionSession);</span><br><span class="line">        if(h265Status != noErr) &#123;</span><br><span class="line">            NSLog(@&quot;XDXHardwareEncoder : H265 VTCompressionSessionPrepareToEncodeFrames Failed, status = %d&quot;,h265Status);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            initializedH265     = true;</span><br><span class="line">            NSLog(@&quot;XDXHardwareEncoder : H265 VTSession create success, with = %d, height = %d, framerate = %d&quot;,self.width,self.height,self.fps);</span><br><span class="line">        &#125;</span><br><span class="line">        if(h265Status != noErr &amp;&amp; self.h265ErrCount != 0) isRestart = YES;</span><br><span class="line">        [m_h265_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (isRestart) &#123;</span><br><span class="line">        NSLog(@&quot;XDXHardwareEncoder : VTSession create failured!&quot;);</span><br><span class="line">            static int count = 0;</span><br><span class="line">            count ++;</span><br><span class="line">            if (count == 3) &#123;</span><br><span class="line">                NSLog(@&quot;TVUEncoder ： restart 5 times failured! exit!&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(1);</span><br><span class="line">            NSLog(@&quot;TVUEncoder ： try to restart after 1 second!&quot;);</span><br><span class="line">            NSLog(@&quot;TVUEncoder ： vtsession error occured!,resetart encoder width: %d, height %d, times %d&quot;,self.width,self.height,count);</span><br><span class="line">            [self tearDownSession];</span><br><span class="line">            [self prepareForEncode];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1&gt; <code>g_isSupportRealTimeEncoder = (is64Bit == 8) ? true : false;</code>用来判断当前设备是32位还是64位</p>
<p>2&gt; 创建H264/H265Session 区别仅仅为参数的不同，h264为kCMVideoCodecType_H264。 h265为kCMVideoCodecType_HEVC，在创建Session指定了回调函数后，当编码成功一帧就会调用相应的回调函数。</p>
<p>3&gt; 通过<code>[self getSupportedPropertyFlags];</code>获取当前编码器支持设置的属性，经过测试，H265不支持码率的限制。目前暂时得不到解决。等待苹果后续处理。</p>
<p>4&gt; 之后设置编码器相关属性，下面会具体介绍，设置完成后则调用VTCompressionSessionPrepareToEncodeFrames准备编码。</p>
<ul>
<li>设置编码器相关属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">- (OSStatus)setSessionProperty:(VTCompressionSessionRef)session key:(CFStringRef)key value:(CFTypeRef)value &#123;</span><br><span class="line">    OSStatus status = VTSessionSetProperty(session, key, value);</span><br><span class="line">    if (status != noErr)  &#123;</span><br><span class="line">        NSString *sessionStr;</span><br><span class="line">        if (session == h264CompressionSession) &#123;</span><br><span class="line">            sessionStr = @&quot;h264 Session&quot;;</span><br><span class="line">            self.h264ErrCount++;</span><br><span class="line">        &#125;else if (session == h265CompressionSession) &#123;</span><br><span class="line">            sessionStr = @&quot;h265 Session&quot;;</span><br><span class="line">            self.h265ErrCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;XDXHardwareEncoder : Set %s of %s Failed, status = %d&quot;,CFStringGetCStringPtr(key, kCFStringEncodingUTF8),sessionStr.UTF8String,status);</span><br><span class="line">    &#125;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applyAllSessionProperty:(VTCompressionSessionRef)session propertyArr:(NSArray *)propertyArr &#123;</span><br><span class="line">    OSStatus status;</span><br><span class="line">    if(!g_isSupportRealTimeEncoder) &#123;</span><br><span class="line">        /* increase max frame delay from 3 to 6 to reduce encoder pressure*/</span><br><span class="line">        int         value = 3;</span><br><span class="line">        CFNumberRef ref   = CFNumberCreate(NULL, kCFNumberSInt32Type, &amp;value);</span><br><span class="line">        [self setSessionProperty:session key:kVTCompressionPropertyKey_MaxFrameDelayCount value:ref];</span><br><span class="line">        CFRelease(ref);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(self.fps) &#123;</span><br><span class="line">        if([self isSupportPropertyWithKey:Key_ExpectedFrameRate inArray:propertyArr]) &#123;</span><br><span class="line">            int         value = self.fps;</span><br><span class="line">            CFNumberRef ref   = CFNumberCreate(NULL, kCFNumberSInt32Type, &amp;value);</span><br><span class="line">            [self setSessionProperty:session key:kVTCompressionPropertyKey_ExpectedFrameRate value:ref];</span><br><span class="line">            CFRelease(ref);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;XDXHardwareEncoder : Current fps is 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(self.bitrate) &#123;</span><br><span class="line">        if([self isSupportPropertyWithKey:Key_AverageBitRate inArray:propertyArr]) &#123;</span><br><span class="line">            int value = self.bitrate;</span><br><span class="line">            if (session == h265CompressionSession) value = 2*1000;  // if current session is h265, Set birate 2M.</span><br><span class="line">            CFNumberRef ref = CFNumberCreate(NULL, kCFNumberSInt32Type, &amp;value);</span><br><span class="line">            [self setSessionProperty:session key:kVTCompressionPropertyKey_AverageBitRate value:ref];</span><br><span class="line">            CFRelease(ref);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;XDXHardwareEncoder : Current bitrate is 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*2016-11-15,@gang, iphone7/7plus do not support realtime encoding, so disable it</span><br><span class="line">     otherwize ,we can not control encoding bit rate</span><br><span class="line">     */</span><br><span class="line">    if (![[self deviceVersion] isEqualToString:@&quot;iPhone9,1&quot;] &amp;&amp; ![[self deviceVersion] isEqualToString:@&quot;iPhone9,2&quot;]) &#123;</span><br><span class="line">        if(g_isSupportRealTimeEncoder) &#123;</span><br><span class="line">            if([self isSupportPropertyWithKey:Key_RealTime inArray:propertyArr]) &#123;</span><br><span class="line">                NSLog(@&quot;use RealTimeEncoder&quot;);</span><br><span class="line">                NSLog(@&quot;XDXHardwareEncoder : use realTimeEncoder&quot;);</span><br><span class="line">                [self setSessionProperty:session key:kVTCompressionPropertyKey_RealTime value:kCFBooleanTrue];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if([self isSupportPropertyWithKey:Key_AllowFrameReordering inArray:propertyArr]) &#123;</span><br><span class="line">        [self setSessionProperty:session key:kVTCompressionPropertyKey_AllowFrameReordering value:kCFBooleanFalse];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(g_isSupportRealTimeEncoder) &#123;</span><br><span class="line">        if([self isSupportPropertyWithKey:Key_ProfileLevel inArray:propertyArr]) &#123;</span><br><span class="line">            [self setSessionProperty:session key:kVTCompressionPropertyKey_ProfileLevel value:self.enableH264 ? kVTProfileLevel_H264_Main_AutoLevel : kVTProfileLevel_HEVC_Main_AutoLevel];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        if([self isSupportPropertyWithKey:Key_ProfileLevel inArray:propertyArr]) &#123;</span><br><span class="line">            [self setSessionProperty:session key:kVTCompressionPropertyKey_ProfileLevel value:self.enableH264 ? kVTProfileLevel_H264_Baseline_AutoLevel : kVTProfileLevel_HEVC_Main_AutoLevel];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (self.enableH264) &#123;</span><br><span class="line">            if([self isSupportPropertyWithKey:Key_H264EntropyMode inArray:propertyArr]) &#123;</span><br><span class="line">                [self setSessionProperty:session key:kVTCompressionPropertyKey_H264EntropyMode value:kVTH264EntropyMode_CAVLC];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if([self isSupportPropertyWithKey:Key_MaxKeyFrameIntervalDuration inArray:propertyArr]) &#123;</span><br><span class="line">        int         value   = 1;</span><br><span class="line">        CFNumberRef ref     = CFNumberCreate(NULL, kCFNumberSInt32Type, &amp;value);</span><br><span class="line">        [self setSessionProperty:session key:kVTCompressionPropertyKey_MaxKeyFrameIntervalDuration value:ref];</span><br><span class="line">        CFRelease(ref);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述方法主要设置启动编码器所需的各个参数</p>
<p>1&gt; kVTCompressionPropertyKey_MaxFrameDelayCount : 压缩器被允许保持的最大帧数在输出一个压缩帧之前。例如如果最大帧延迟数是M,那么在编码帧N返回的调用之前，帧N-M必须被排出。</p>
<p>2&gt; kVTCompressionPropertyKey_ExpectedFrameRate : 设置fps</p>
<p>3&gt; kVTCompressionPropertyKey_AverageBitRate : 它不是强制的限制，bit rate可能会超出峰值</p>
<p>4&gt; kVTCompressionPropertyKey_RealTime : 设置编码器是否实时编码，如果设置为False则不是实时编码，视频效果会更好一点。</p>
<p>5&gt; kVTCompressionPropertyKey_AllowFrameReordering : 是否让帧进行重新排序。为了编码B帧，编码器必须对帧重新排序，这将意味着解码的顺序与显示的顺序不同。将其设置为false以防止帧重新排序。</p>
<p>6&gt; kVTCompressionPropertyKey_ProfileLevel : 指定编码比特流的配置文件和级别</p>
<p>7&gt; kVTCompressionPropertyKey_H264EntropyMode ：如果支持h264该属性设置编码器是否应该使用基于CAVLC 还是 CABAC</p>
<p>8&gt; kVTCompressionPropertyKey_MaxKeyFrameIntervalDuration : 两个I帧之间最大持续时间，该属性特别有用当frame rate是可变</p>
<ul>
<li>相机回调中对每一帧数据进行编码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123;</span><br><span class="line">    if( !CMSampleBufferDataIsReady(sampleBuffer)) &#123;</span><br><span class="line">        NSLog( @&quot;sample buffer is not ready. Skipping sample&quot; );</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if([XDXHardwareEncoder getInstance] != NULL) &#123;</span><br><span class="line">        [[XDXHardwareEncoder getInstance] encode:sampleBuffer];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上方法在每采集到一帧视频数据后会调用一次，我们将拿到的每一帧数据进行编码。</p>
<ul>
<li>编码具体实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">-(void)encode:(CMSampleBufferRef)sampleBuffer &#123;</span><br><span class="line">    if (self.enableH264) &#123;</span><br><span class="line">        [m_h264_lock lock];</span><br><span class="line">        if(h264CompressionSession == NULL) &#123;</span><br><span class="line">            [m_h264_lock unlock];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(initializedH264 == false) &#123;</span><br><span class="line">            NSLog(@&quot;TVUEncoder : h264 encoder is not ready\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.enableH265) &#123;</span><br><span class="line">        [m_h265_lock lock];</span><br><span class="line">        if(h265CompressionSession == NULL) &#123;</span><br><span class="line">            [m_h265_lock unlock];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(initializedH265 == false) &#123;</span><br><span class="line">            NSLog(@&quot;TVUEncoder : h265 encoder is not ready\n&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);</span><br><span class="line">    CMTime duration = CMSampleBufferGetOutputDuration(sampleBuffer);</span><br><span class="line">    frameID++;</span><br><span class="line">    CMTime presentationTimeStamp = CMTimeMake(frameID, 1000);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    [self doSetBitrate];</span><br><span class="line">    </span><br><span class="line">    OSStatus status;</span><br><span class="line">    VTEncodeInfoFlags flags;</span><br><span class="line">    if (self.enableH264) &#123;</span><br><span class="line">        status = VTCompressionSessionEncodeFrame(h264CompressionSession, imageBuffer, presentationTimeStamp, duration, NULL, imageBuffer, &amp;flags);</span><br><span class="line">        if(status != noErr) NSLog(@&quot;TVUEncoder : H264 VTCompressionSessionEncodeFrame failed&quot;);</span><br><span class="line">        [m_h264_lock unlock];</span><br><span class="line">        </span><br><span class="line">        if (status != noErr) &#123;</span><br><span class="line">            NSLog(@&quot;TVUEncoder : VTCompressionSessionEncodeFrame failed&quot;);</span><br><span class="line">            VTCompressionSessionCompleteFrames(h264CompressionSession, kCMTimeInvalid);</span><br><span class="line">            VTCompressionSessionInvalidate(h264CompressionSession);</span><br><span class="line">            CFRelease(h264CompressionSession);</span><br><span class="line">            h264CompressionSession = NULL;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            // NSLog(@&quot;TVUEncoder : Success VTCompressionSessionCompleteFrames&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (self.enableH265) &#123;</span><br><span class="line">        status = VTCompressionSessionEncodeFrame(h265CompressionSession, imageBuffer, presentationTimeStamp, duration, NULL, imageBuffer, &amp;flags);</span><br><span class="line">        if(status != noErr) NSLog(@&quot;TVUEncoder : H265 VTCompressionSessionEncodeFrame failed&quot;);</span><br><span class="line">        [m_h265_lock unlock];</span><br><span class="line">        </span><br><span class="line">        if (status != noErr) &#123;</span><br><span class="line">            NSLog(@&quot;TVUEncoder : VTCompressionSessionEncodeFrame failed&quot;);</span><br><span class="line">            VTCompressionSessionCompleteFrames(h265CompressionSession, kCMTimeInvalid);</span><br><span class="line">            VTCompressionSessionInvalidate(h265CompressionSession);</span><br><span class="line">            CFRelease(h265CompressionSession);</span><br><span class="line">            h265CompressionSession = NULL;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            NSLog(@&quot;TVUEncoder : Success VTCompressionSessionCompleteFrames&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>1&gt; 通过frameID的递增构造时间戳为了使编码后的每一帧数据连续</p>
<p>2&gt; 设置最大码率的限制，注意：H265目前不支持设置码率的限制，等待官方后续通知。可以对H264进行码率限制</p>
<p>3&gt; kVTCompressionPropertyKey_DataRateLimits : 将数据的bytes和duration封装到CFMutableArrayRef传给API进行调用</p>
<p>4&gt; VTCompressionSessionEncodeFrame : 调用此方法成功后触发回调函数完成编码。</p>
<ul>
<li>回调函数中处理头信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark H264 Callback</span><br><span class="line">static void vtCallBack(void *outputCallbackRefCon,void *souceFrameRefCon,OSStatus status,VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer) &#123;</span><br><span class="line">    XDXHardwareEncoder *encoder = (__bridge XDXHardwareEncoder*)outputCallbackRefCon;</span><br><span class="line">    if(status != noErr) &#123;</span><br><span class="line">        NSError *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil];</span><br><span class="line">        NSLog(@&quot;H264: vtCallBack failed with %@&quot;, error);</span><br><span class="line">        NSLog(@&quot;XDXHardwareEncoder : encode frame failured! %s&quot; ,error.debugDescription.UTF8String);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!CMSampleBufferDataIsReady(sampleBuffer)) &#123;</span><br><span class="line">        NSLog(@&quot;didCompressH265 data is not ready &quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (infoFlags == kVTEncodeInfo_FrameDropped) &#123;</span><br><span class="line">        NSLog(@&quot;%s with frame dropped.&quot;, __FUNCTION__);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CMBlockBufferRef block = CMSampleBufferGetDataBuffer(sampleBuffer);</span><br><span class="line">    BOOL isKeyframe = false;</span><br><span class="line"></span><br><span class="line">    CFArrayRef attachments = CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, false);</span><br><span class="line"></span><br><span class="line">    if(attachments != NULL) &#123;</span><br><span class="line">        CFDictionaryRef attachment =(CFDictionaryRef)CFArrayGetValueAtIndex(attachments, 0);</span><br><span class="line">        CFBooleanRef dependsOnOthers = (CFBooleanRef)CFDictionaryGetValue(attachment, kCMSampleAttachmentKey_DependsOnOthers);</span><br><span class="line">        isKeyframe = (dependsOnOthers == kCFBooleanFalse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(isKeyframe) &#123;</span><br><span class="line">        CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);</span><br><span class="line">        static uint8_t *spsppsNALBuff = NULL;</span><br><span class="line">        static size_t  spsSize, ppsSize;</span><br><span class="line"></span><br><span class="line">            size_t parmCount;</span><br><span class="line">            const uint8_t*sps, *pps;</span><br><span class="line">            int NALUnitHeaderLengthOut;</span><br><span class="line">            CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sps, &amp;spsSize, &amp;parmCount, &amp;NALUnitHeaderLengthOut );</span><br><span class="line">            CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pps, &amp;ppsSize, &amp;parmCount, &amp;NALUnitHeaderLengthOut );</span><br><span class="line"></span><br><span class="line">            spsppsNALBuff = (uint8_t*)malloc(spsSize+4+ppsSize+4);</span><br><span class="line">            memcpy(spsppsNALBuff, &quot;\x00\x00\x00\x01&quot;, 4);</span><br><span class="line">            memcpy(&amp;spsppsNALBuff[4], sps, spsSize);</span><br><span class="line">            memcpy(&amp;spsppsNALBuff[4+spsSize], &quot;\x00\x00\x00\x01&quot;, 4);</span><br><span class="line">            memcpy(&amp;spsppsNALBuff[4+spsSize+4], pps, ppsSize);</span><br><span class="line">            NSLog(@&quot;XDXHardwareEncoder : H264 spsSize : %zu, ppsSize : %zu&quot;,spsSize, ppsSize);</span><br><span class="line">         writeFile(spsppsNALBuff,spsSize+4+ppsSize+4,encoder-&gt;_videoFile, 200);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t blockBufferLength;</span><br><span class="line">    uint8_t *bufferDataPointer = NULL;</span><br><span class="line">    CMBlockBufferGetDataPointer(block, 0, NULL, &amp;blockBufferLength, (char **)&amp;bufferDataPointer);</span><br><span class="line"></span><br><span class="line">    size_t bufferOffset = 0;</span><br><span class="line">    while (bufferOffset &lt; blockBufferLength - startCodeLength) &#123;</span><br><span class="line">        uint32_t NALUnitLength = 0;</span><br><span class="line">        memcpy(&amp;NALUnitLength, bufferDataPointer+bufferOffset, startCodeLength);</span><br><span class="line">        NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);</span><br><span class="line">        memcpy(bufferDataPointer+bufferOffset, startCode, startCodeLength);</span><br><span class="line">        bufferOffset += startCodeLength + NALUnitLength;</span><br><span class="line">    &#125;</span><br><span class="line">    writeFile(bufferDataPointer, blockBufferLength,encoder-&gt;_videoFile, 200);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark H265 Callback</span><br><span class="line">static void vtH265CallBack(void *outputCallbackRefCon,void *souceFrameRefCon,OSStatus status,VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer) &#123;</span><br><span class="line">    XDXHardwareEncoder *encoder = (__bridge XDXHardwareEncoder*)outputCallbackRefCon;</span><br><span class="line">    if(status != noErr) &#123;</span><br><span class="line">        NSError *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil];</span><br><span class="line">        NSLog(@&quot;H264: H265 vtH265CallBack failed with %@&quot;, error);</span><br><span class="line">        NSLog(@&quot;XDXHardwareEncoder : H265 encode frame failured! %s&quot; ,error.debugDescription.UTF8String);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!CMSampleBufferDataIsReady(sampleBuffer)) &#123;</span><br><span class="line">        NSLog(@&quot;didCompressH265 data is not ready &quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (infoFlags == kVTEncodeInfo_FrameDropped) &#123;</span><br><span class="line">        NSLog(@&quot;%s with frame dropped.&quot;, __FUNCTION__);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CMBlockBufferRef block = CMSampleBufferGetDataBuffer(sampleBuffer);</span><br><span class="line">    BOOL isKeyframe = false;</span><br><span class="line"></span><br><span class="line">    CFArrayRef attachments = CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, false);</span><br><span class="line"></span><br><span class="line">    if(attachments != NULL) &#123;</span><br><span class="line">        CFDictionaryRef attachment =(CFDictionaryRef)CFArrayGetValueAtIndex(attachments, 0);</span><br><span class="line">        CFBooleanRef dependsOnOthers = (CFBooleanRef)CFDictionaryGetValue(attachment, kCMSampleAttachmentKey_DependsOnOthers);</span><br><span class="line">        isKeyframe = (dependsOnOthers == kCFBooleanFalse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(isKeyframe) &#123;</span><br><span class="line">        CMFormatDescriptionRef format     = CMSampleBufferGetFormatDescription(sampleBuffer);</span><br><span class="line">        static uint8_t *vpsspsppsNALBuff  = NULL;</span><br><span class="line">        static size_t  vpsSize, spsSize, ppsSize;</span><br><span class="line">            size_t parmCount;</span><br><span class="line">            const uint8_t *vps, *sps, *pps;</span><br><span class="line"></span><br><span class="line">            if (encoder.deviceSupportH265) &#123;       // &gt;= iPhone 7 &amp;&amp; support ios11</span><br><span class="line">                CMVideoFormatDescriptionGetHEVCParameterSetAtIndex(format, 0, &amp;vps, &amp;vpsSize, &amp;parmCount, 0);</span><br><span class="line">                CMVideoFormatDescriptionGetHEVCParameterSetAtIndex(format, 1, &amp;sps, &amp;spsSize, &amp;parmCount, 0);</span><br><span class="line">                CMVideoFormatDescriptionGetHEVCParameterSetAtIndex(format, 2, &amp;pps, &amp;ppsSize, &amp;parmCount, 0);</span><br><span class="line"></span><br><span class="line">                vpsspsppsNALBuff = (uint8_t*)malloc(vpsSize+4+spsSize+4+ppsSize+4);</span><br><span class="line">                memcpy(vpsspsppsNALBuff, &quot;\x00\x00\x00\x01&quot;, 4);</span><br><span class="line">                memcpy(&amp;vpsspsppsNALBuff[4], vps, vpsSize);</span><br><span class="line">                memcpy(&amp;vpsspsppsNALBuff[4+vpsSize], &quot;\x00\x00\x00\x01&quot;, 4);</span><br><span class="line">                memcpy(&amp;vpsspsppsNALBuff[4+vpsSize+4], sps, spsSize);</span><br><span class="line">                memcpy(&amp;vpsspsppsNALBuff[4+vpsSize+4+spsSize], &quot;\x00\x00\x00\x01&quot;, 4);</span><br><span class="line">                memcpy(&amp;vpsspsppsNALBuff[4+vpsSize+4+spsSize+4], pps, ppsSize);</span><br><span class="line">                NSLog(@&quot;XDXHardwareEncoder : H265 vpsSize : %zu, spsSize : %zu, ppsSize : %zu&quot;,vpsSize,spsSize, ppsSize);</span><br><span class="line">            &#125;</span><br><span class="line">             writeFile(vpsspsppsNALBuff, vpsSize+4+spsSize+4+ppsSize+4,encoder-&gt;_videoFile, 200);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t   blockBufferLength;</span><br><span class="line">    uint8_t  *bufferDataPointer = NULL;</span><br><span class="line">    CMBlockBufferGetDataPointer(block, 0, NULL, &amp;blockBufferLength, (char **)&amp;bufferDataPointer);</span><br><span class="line"></span><br><span class="line">    size_t bufferOffset = 0;</span><br><span class="line">    while (bufferOffset &lt; blockBufferLength - startCodeLength) &#123;</span><br><span class="line">        uint32_t NALUnitLength = 0;</span><br><span class="line">        memcpy(&amp;NALUnitLength, bufferDataPointer+bufferOffset, startCodeLength);</span><br><span class="line">        NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);</span><br><span class="line">        memcpy(bufferDataPointer+bufferOffset, startCode, startCodeLength);</span><br><span class="line">        bufferOffset += startCodeLength + NALUnitLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     writeFile(bufferDataPointer, blockBufferLength,encoder-&gt;_videoFile, 200);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>1&gt; 首先在回调函数中截取到I帧，从I帧中提取到(h265中新增vps),sps,pps信息并写入文件<br>2&gt; 遍历其他帧将头信息0000,0001写入每个头信息中，再将该数据写入文件即可</p>
<h2 id="二-码流数据结构介绍"><a href="#二-码流数据结构介绍" class="headerlink" title="二.码流数据结构介绍"></a>二.码流数据结构介绍</h2><p>这里我们简单介绍一下H264,H265码流信息</p>
<ol>
<li><p>H264流数据是由一系列NAL单元(NAL Unit)组成的。</p>
</li>
<li><p>一个NALU可能包含：视频帧，视频帧也就是视频片段，具体有I,P,B帧</p>
<p><img src="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/KExDsa2RJzGpe6a9NBTKJClrkX3HpcT68p2i4pqoJyY!/r/dOAAAAAAAAAA" alt="H264的码流"></p>
</li>
<li><p>H.264属性合集-FormatDesc(包含 SPS和PPS)</p>
</li>
</ol>
<p><img src="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/yuYb34e.S.4UoETVIJDPI1L6DYdVGdlKfW80wULI.T8!/r/dHYBAAAAAAAA" alt="属性集合"></p>
<p>注意在H265流数据中新增vps在最前。</p>
<ul>
<li>H.264属性合集-FormatDesc(包含 SPS和PPS)</li>
</ul>
<p>流数据中，属性集合可能是这样的：</p>
<p>经过处理之后，在Format Description中则是:</p>
<p><img src="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/YUsq7p4oq0E8Uvz5hYxFAxH2pA.NoV38kiwjRwYjtZY!/r/dGwBAAAAAAAA" alt="Format Description"></p>
<ul>
<li>NALU header<br>对于流数据来说，一个NALU的Header中，可能是0x00 00 01或者是0x00 00 00 01作为开头(两者都有可能，下面以0x00 00 01作为例子)。0x00 00 01因此被称为开始码(Start code).所以我们需要在提取的数据中用0x00 00 00 01对数据内容进行替换</li>
</ul>
<p><img src="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/6LWUuXOk2xoelipoT3Lbu6qJQDTfOemFXg55YP1dh.U!/r/dDwBAAAAAAAA" alt="NALU header"></p>
<blockquote>
<p>总结以上知识，我们知道H264的码流由NALU单元组成，NALU单元包含视频图像数据和H264的参数信息。其中视频图像数据就是CMBlockBuffer，而H264的参数信息则可以组合成FormatDesc。具体来说参数信息包含SPS（Sequence Parameter Set）和PPS（Picture Parameter Set）.如下图显示了一个H.264码流结构：</p>
</blockquote>
<p><img src="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/dLoOAI2WwVn2yGsmI0W3nqkRQplUQzK0w5gl99vUYkU!/r/dOAAAAAAAAAA" alt="H.264码流"></p>
<ul>
<li><p>提取sps和pps生成FormatDesc</p>
<ul>
<li>每个NALU的开始码是0x00 00 01，按照开始码定位NALU</li>
<li>通过类型信息找到sps和pps并提取，开始码后第一个byte的后5位，7代表sps，8代表pps</li>
<li>使用CMVideoFormatDescriptionCreateFromH264ParameterSets函数来构建CMVideoFormatDescriptionRef</li>
</ul>
</li>
<li><p>提取视频图像数据生成CMBlockBuffer</p>
<ul>
<li>通过开始码，定位到NALU</li>
<li>确定类型为数据后，将开始码替换成NALU的长度信息（4 Bytes）</li>
<li>使用CMBlockBufferCreateWithMemoryBlock接口构造CMBlockBufferRef</li>
</ul>
</li>
<li><p>根据需要，生成CMTime信息。（实际测试时，加入time信息后，有不稳定的图像，不加入time信息反而没有，需要进一步研究，这里建议不加入time信息）</p>
</li>
</ul>
<p>根据上述得到CMVideoFormatDescriptionRef、CMBlockBufferRef和可选的时间信息，使用CMSampleBufferCreate接口得到CMSampleBuffer数据这个待解码的原始的数据。如下图所示的H264数据转换示意图。</p>
<p><img src="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/wNFEFe7Lz7M5qCeNJNPrrSwyQjJdG3.J75X1vkszvn8!/r/dCsAAAAAAAAA" alt="CMSampleBufferCreate"></p>
<h3 id="编码器知识可参考-H264-H265编码器介绍"><a href="#编码器知识可参考-H264-H265编码器介绍" class="headerlink" title="编码器知识可参考:H264,H265编码器介绍"></a>编码器知识可参考:<a href="http://www.jianshu.com/p/668e6abbed8c" target="_blank" rel="noopener">H264,H265编码器介绍</a></h3>
      
    </div>

    

    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>穷则github点星,达可兼济本人</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="小东邪 - Demon WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="小东邪 - Demon Alipay">
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/编解码-Encode-Decode/" rel="tag"># 编解码(Encode/Decode)</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/26/record/" rel="next" title="Audio -- PCM to AAC">
                <i class="fa fa-chevron-left"></i> Audio -- PCM to AAC
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/06/20181106_iOS_WKWebViewUI/" rel="prev" title="iOS WKWebView UI增强(上拉刷新，JS交互，加载进度条)">
                iOS WKWebView UI增强(上拉刷新，JS交互，加载进度条) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
        <div onclick="showGitment()" id="gitment_title" class="gitment_title">显示 Gitment 评论</div>
        <div id="container" style="display:none"></div>
        <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
        <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
        <script>
        const myTheme = {
          render(state, instance) {
            const container = document.createElement('div');
            container.lang = "en-US";
            container.className = 'gitment-container gitment-root-container';
            container.appendChild(instance.renderHeader(state, instance));
            container.appendChild(instance.renderEditor(state, instance));
            container.appendChild(instance.renderComments(state, instance));
            container.appendChild(instance.renderFooter(state, instance));
            return container;
          }
        }
        function showGitment() {
          $("#gitment_title").attr("style", "display:none");
          $("#container").attr("style", "").addClass("gitment_container");
          var gitment = new Gitment({
            id: window.location.pathname,
            theme: myTheme,
            owner: '',
            repo: '',
            oauth: {
              client_id: 'c209d8cfa2d7f7696f17',
              client_secret: '1681a33c8745e7a79871dfc6613170a03c44fed8'
            }
          });
          gitment.render('container');
        }
        </script>

  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://r.photo.store.qq.com/psb?/V14Id4Zj1TAt9e/yzeIpXHXXaOcxOnovNgST0jvIeuupEGzPfZ3DWoYrLY!/r/dFQBAAAAAAAA" alt="小东邪 - Demon">
            
              <p class="site-author-name" itemprop="name">小东邪 - Demon</p>
              <p class="site-description motion-element" itemprop="description">一生负气成今日，四海无人对夕阳.</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">45</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/XiaoDongXie1024" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/23f3ec991fed" target="_blank" title="简书"><i class="fa fa-fw fa-book"></i>简书</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://juejin.im/user/58ec343861ff4b00691b4f26" target="_blank" title="掘金"><i class="fa fa-fw fa-star"></i>掘金</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#——————————————————–"><span class="nav-number">1.</span> <span class="nav-text">——————————————————–</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本例需求：使用H264-H265实现视频数据的编码并录制开始200帧存为文件"><span class="nav-number">2.</span> <span class="nav-text">本例需求：使用H264, H265实现视频数据的编码并录制开始200帧存为文件.</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#原理：比如做直播功能，需要将客户端的视频数据传给服务器，如果分辨率过大如2K-4K则传输压力太大，所以需要对视频数据进行编码，传给服务器后再解码以实现大数据量的视频数据的传输，而利用硬件编码则可以极大限度减小CPU压力，当前主流使用H264进行编码，iOS-11-之后，iPhone-7以上的设备可以支持新的编码器H265编码器，使得同等质量视频占用的存储空间更小。所以本例中可以使用两种方式实现视频数据的编码"><span class="nav-number">2.0.1.</span> <span class="nav-text">原理：比如做直播功能，需要将客户端的视频数据传给服务器，如果分辨率过大如2K,4K则传输压力太大，所以需要对视频数据进行编码，传给服务器后再解码以实现大数据量的视频数据的传输，而利用硬件编码则可以极大限度减小CPU压力，当前主流使用H264进行编码，iOS 11 之后，iPhone 7以上的设备可以支持新的编码器H265编码器，使得同等质量视频占用的存储空间更小。所以本例中可以使用两种方式实现视频数据的编码</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#——————————————————–-1"><span class="nav-number">3.</span> <span class="nav-text">——————————————————–</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最终效果如下-：-h264"><span class="nav-number">3.1.</span> <span class="nav-text">最终效果如下 ： h264</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#h265"><span class="nav-number">3.2.</span> <span class="nav-text">h265 :</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#——————————————————–-2"><span class="nav-number">4.</span> <span class="nav-text">——————————————————–</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GitHub地址-附代码-H264-H265Encode"><span class="nav-number">4.1.</span> <span class="nav-text">GitHub地址(附代码) : H264,H265Encode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简书地址-H264-H265Encode"><span class="nav-number">4.2.</span> <span class="nav-text">简书地址     : H264,H265Encode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#博客地址-H264-H265Encode"><span class="nav-number">4.3.</span> <span class="nav-text">博客地址     : H264,H265Encode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#掘金地址-https-juejin-im-post-5a8fe3def265da4e8e78781b"><span class="nav-number">4.4.</span> <span class="nav-text">掘金地址     : https://juejin.im/post/5a8fe3def265da4e8e78781b</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#——————————————————–-3"><span class="nav-number">5.</span> <span class="nav-text">——————————————————–</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现方式："><span class="nav-number"></span> <span class="nav-text">实现方式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-H264-H264是当前主流编码标准，以高压缩高质量和支持多种网络的流媒体传输著称"><span class="nav-number">1.</span> <span class="nav-text">1. H264 : H264是当前主流编码标准，以高压缩高质量和支持多种网络的流媒体传输著称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-H265-：H264编码器的下一代，它的主要优点提供的压缩比高，相同质量的视频是H264的两倍。"><span class="nav-number">2.</span> <span class="nav-text">2. H265 ：H264编码器的下一代，它的主要优点提供的压缩比高，相同质量的视频是H264的两倍。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#——————————————————–-4"><span class="nav-number">3.</span> <span class="nav-text">——————————————————–</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一-本文需要基本知识点"><span class="nav-number"></span> <span class="nav-text">一.本文需要基本知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注意-可以先通过H264-H265编码器介绍，H264-Data-Structure了解预备知识。"><span class="nav-number">0.1.</span> <span class="nav-text">注意:可以先通过H264,H265编码器介绍，H264 Data Structure了解预备知识。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-软编与硬编概念"><span class="nav-number">0.2.</span> <span class="nav-text">1. 软编与硬编概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-H265优点"><span class="nav-number">0.3.</span> <span class="nav-text">2.H265优点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-代码解析"><span class="nav-number"></span> <span class="nav-text">二.代码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-实现流程"><span class="nav-number">0.1.</span> <span class="nav-text">1.实现流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-编码器实现流程"><span class="nav-number">0.2.</span> <span class="nav-text">2.编码器实现流程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#注意H265目前不支持码率的限制"><span class="nav-number">0.2.0.1.</span> <span class="nav-text">注意H265目前不支持码率的限制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-主要方法解析"><span class="nav-number">0.3.</span> <span class="nav-text">3.主要方法解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-码流数据结构介绍"><span class="nav-number"></span> <span class="nav-text">二.码流数据结构介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编码器知识可参考-H264-H265编码器介绍"><span class="nav-number">1.</span> <span class="nav-text">编码器知识可参考:H264,H265编码器介绍</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小东邪 - Demon</span>

  

  
</div>








  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.4.2</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="Total Visitors">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="Total Views">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname,
            owner: 'XiaoDongXie1024',
            repo: 'gitment-comments',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '1681a33c8745e7a79871dfc6613170a03c44fed8',
            
                client_id: 'c209d8cfa2d7f7696f17'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    






  





  

  
  <script>
    
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function ({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', `/classes/Counter/${counter.objectId}`, JSON.stringify({ time: { "__op":"Increment", "amount":1 } }))
            
            .done(function () {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.time + 1);
            })
            
            .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
            })
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! See more at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see here how to solve it: https://github.com/theme-next/hexo-leancloud-counter-security. \n But you also can use LeanCloud without security, by set \'security\' option to \'false\'.');
            
          }
        })
      .fail(function ({ responseJSON }) {
        console.log('LeanCloud Counter Error:' + responseJSON.code + " " + responseJSON.error);
      });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + "")
        .done(function ({ api_server }) {
          var Counter = function (method, url, data) {
            return $.ajax({
              method: method,
              url: `https://${api_server}/1.1${url}`,
              headers: {
                'X-LC-Id': "",
                'X-LC-Key': "",
                'Content-Type': 'application/json',
              },
              data: data,
            });
          };
          
          addCount(Counter);
          
        })
    });
  </script>



  

  

  

  
  

  

  

  

  

  

</body>
</html>
